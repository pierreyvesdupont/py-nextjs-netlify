{"ast":null,"code":"import fs from \"fs\";\nimport matter from \"gray-matter\";\nimport path from \"path\";\nimport yaml from \"js-yaml\";\nconst postsDirectory = path.join(process.cwd(), \"content/posts\");\nlet postCache;\nexport function fetchPostContent() {\n  if (postCache) {\n    return postCache;\n  } // Get file names under /posts\n\n\n  const fileNames = fs.readdirSync(postsDirectory);\n  const allPostsData = fileNames.filter(it => it.endsWith(\".mdx\")).map(fileName => {\n    // Read markdown file as string\n    const fullPath = path.join(postsDirectory, fileName);\n    const fileContents = fs.readFileSync(fullPath, \"utf8\"); // Use gray-matter to parse the post metadata section\n\n    const matterResult = matter(fileContents, {\n      engines: {\n        yaml: s => yaml.load(s, {\n          schema: yaml.JSON_SCHEMA\n        })\n      }\n    });\n    const matterData = matterResult.data;\n    matterData.fullPath = fullPath;\n    const slug = fileName.replace(/\\.mdx$/, \"\"); // Validate slug string\n\n    if (matterData.slug !== slug) {\n      throw new Error(\"slug field not match with the path of its content source\");\n    }\n\n    return matterData;\n  }); // Sort posts by date\n\n  postCache = allPostsData.sort((a, b) => {\n    if (a.date < b.date) {\n      return 1;\n    } else {\n      return -1;\n    }\n  });\n  return postCache;\n}\nexport function countPosts(tag) {\n  return fetchPostContent().filter(it => !tag || it.tags && it.tags.includes(tag)).length;\n}\nexport function listPostContent(page, limit, tag) {\n  return fetchPostContent().filter(it => !tag || it.tags && it.tags.includes(tag)).slice((page - 1) * limit, page * limit);\n}","map":null,"metadata":{},"sourceType":"module"}